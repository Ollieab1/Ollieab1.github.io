<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>H264_SEI</title>
    <link href="/2023/12/03/H264-SEI/"/>
    <url>/2023/12/03/H264-SEI/</url>
    
    <content type="html"><![CDATA[<h2 id="H264的SEI信息"><a href="#H264的SEI信息" class="headerlink" title="H264的SEI信息"></a>H264的SEI信息</h2><h3 id="SEI的简介"><a href="#SEI的简介" class="headerlink" title="SEI的简介"></a>SEI的简介</h3><p>补充增强信息（Supplemental Enhancement Information）是码流范畴里面的概念，提供了向视频码流中加入信息的办法，是H.264&#x2F;H.265 视频压缩标准的特性之一。SEI 有基本的特征：</p><ol><li>并不是解码过程的必须项；</li><li>有可能对解码过程（容错、纠错）有帮助；</li><li>集成在视频码流中；</li></ol><p>这意味着视频编码器在输出视频码流的时候，可以不提供SEI信息 。同时我们也要清楚：视频传输过程、解封装、解码环节，都可能因为某种原因丢弃SEI 。 在视频内容的生成端、传输过程中，都可以插入SEI 信息。插入的信息，和其他视频内容一起经过传输链路到达了消费端。那么在SEI 中可以添加哪些信息呢？这里举几个例子，用户场景可以任意扩展：</p><ol><li>传递编码器参数；</li><li>传递视频版权信息;</li><li>传递摄像头参数；</li><li>传递内容生成过程中的剪辑事件（引发场景切换）；</li></ol><h3 id="H264码流结构"><a href="#H264码流结构" class="headerlink" title="H264码流结构"></a>H264码流结构</h3><p>（1）H264码流，是由一个个独立的数据块NALU组成，NALU数据块之间相互关联，NALU数据块的顺序不可以调换，但NALU数据块之间可以插入指定格式的数据，理论上插入数据的长度不限。</p><p>（2）解码器在解码时，首先遍历码流中的Start code（00 00 00 01），找到Start code后紧跟着解析NALU单元，解析时从前往后遍历，直至找到下一个Start code，并开始下一帧NALU单元的解析。</p><p>（3）H264码流中插入自定义数据，首先将自定义数据按特定的格式封装成一个数组，然后在码流的每个I帧或者P帧之前插入自定义数据即可</p><ul><li>码流格式图解</li></ul><p>网络抽象层（Network Abstract Layer）简称为NAL。在H.264&#x2F;AVC视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（Video Coding Layer - VCL）和网络抽象层面（Network Abstraction Layer - NAL）。VCL负责表示有效视频数据的内容，NAL 负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。NAL unit是NAL的基本语法结构，它包含一个字节的头信息（NAL header）和一系列来自VCL的原始数据字节流（RBSP）</p><p>NAL unit type储存在NAL header中，在H.264&#x2F;AVC标准中，可用的NAL unit type一共有17种，其中值为6时表征SEI 内容。比较常见的类型如下表所示：</p><p><img src="/H264-SEI/1.png"></p><ul><li>H264码流数据块组合示例</li></ul><p><img src="/img/2.png"></p><ul><li>自定义数据封装以及H264码流插入</li></ul><p><img src="/img/3.png"></p><ul><li>SEI字段自定义封装包格式为</li></ul><p>1）Start code：每个NALU单元的起始码</p><p>2）NRI：高四位的第一位为禁止位0，决定该NALU单元是否有效；高四位中间两位表示该NALU单元的重要程度，解码时根据该数值决定该NALU单元解析或丢弃。高四位的最后一位与低四位组成NALU单元识别码，06表示该单元为SEI字段。</p><p>3）payload type：05表示该SEI字段的编码格式符合H264标准格式</p><p>4）UUID：用户自定义的识别码，16字节长度，只要不与Start code冲突即可</p><p>5）自定义数据长度：用两个字节表示封装自定义数据的长度，解码时依据该数值做校验</p><p>6）自定义数据：用户自己封装的数据，类型必须为unsigned char</p><p>7）结尾对齐码：80表示SEI字段的结束对齐</p><h3 id="SEI类型"><a href="#SEI类型" class="headerlink" title="SEI类型"></a>SEI类型</h3><ul><li>读取SEI payload type</li></ul><p>在H.264&#x2F;AVC视频编码标准中，并没有规定SEI payload type的范围，所以表征payload type的字节数是浮动的。<br>语法分析如下所示，当开始解析类型为SEI的NAL时，持续读取8bit，直到非0xff为止，然后把读取的数值累加，累加值即为SEI payload type。</p><pre><code class="hljs">sei_message()&#123;  payloadType = 0  while( next_bits(8) == 0xFF)&#123;        ff_byte        payloadType += 255  &#125;  last_payload_type_byte  payloadType += last_payload_type_byte&#125;</code></pre><ul><li>读取SEI payload size</li></ul><p>读取SEI payload size和payload type逻辑类似，仍然是读取到0xff为止，这样可以支持任意长度的SEI payload添加。</p><pre><code class="hljs">sei_message()&#123;  payloadSize = 0  while( next_bits(8) == 0xFF)&#123;       ff_byte       payloadSize += 255  &#125;  last_payload_size_byte  payloadSize += last_payload_size_byte&#125;</code></pre><p>当获取了SEI payload类型和大小后，就进入了实际的SEI内容读取。</p><p>当前《ISO&#x2F;IEC 14496-10:2014》Annex D.1.1提供了最大到181的payload类型处理规范，由于类型可以指定任意大小，给SEI的添加、处理创造了很大的自由空间。</p><p>其中SEI payload类型值为5时，指定的处理方法叫user_data_unregistered()，字面含义为未注册的用户数据，常用于存储编码器的编码参数信息，是比较常见的payload类型。</p><p>读取payload type为5时，具体的语法解析流程如下：</p><pre><code class="hljs">user_data_unregistered(payloadSize)&#123;  uuid_iso_iec_11578  for( i=16; i&lt; payloadSize; i++)        user_data_payload_byte&#125;</code></pre><p>其中uuid_iso_iec_11578的详细定义在《ISO&#x2F;IEC 11578:1996》Annex A中，大致规定了使用128bits(16个字节)来指定UUID。此处UUID可以表征写入SEI payload的角色ID，或者表征其他业务用途。剩下的payloadSize -16字节，即是业务层传递的具体内容了。</p><p>通过user_data_unregistered()语法解析可以看出，当使用SEI payload type为5时，注意事项如下：</p><p>1）payload size应该大于16；</p><p>2）uuid可能出现0x000000&#x2F;0x000001&#x2F;0x000002，需要插入0x03做防竞争处理；</p><p>构成RBSP时，都需要做RBSP拖尾处理。拖尾处理对所有SODB方式都一致。rbsp_trailing_bits()语法逻辑如下：</p><pre><code class="hljs">rbsp_trailing_bits( )&#123;  rbsp_stop_one_bit  while(!byte_aligned())        rbsp_alignment_zero_bit&#125;</code></pre><h3 id="SEI举例"><a href="#SEI举例" class="headerlink" title="SEI举例"></a>SEI举例</h3><p>如下图所示是一段H264的码流：</p><p><img src="/img/4.png"></p><h4 id="NAL-header"><a href="#NAL-header" class="headerlink" title="NAL header"></a>NAL header</h4><p>起始码（暗红底色）”0x00000001”分割出来的比特流即是NAL unit，起始码紧跟的第一个字节(墨绿底色)是NAL header。上图“NAL header”一共出现了四个数值：</p><p>1）”0x06”，此时NRI为”00B”，NAL unit type为SEI类型。</p><p>2）“0x67”，此时NRI为“11B”，NAL unit type为SPS类型。</p><p>3）“0x68”，此时NRI为“11B”，NAL unit type为PPS类型。</p><p>4）“0x65”，此时NRI为“11B”，NAL unit type为IDR图像。</p><h4 id="SEI-payload-type"><a href="#SEI-payload-type" class="headerlink" title="SEI payload type"></a>SEI payload type</h4><p>“0x06”后一个字节为“0x05”（淡黄底色）是SEI payload type，即表征SEI payload分析遵循user_data_unregistered()语法。</p><p>SEI payload size “0x05”后一个字节为“0x2F”（淡蓝底色）是SEI payload size，此时整个payload是47个字节。</p><p>SEI payload uuid “0x2F”随后的16个字节即为uuid，此时uuid为</p><pre><code class="hljs">dc45e9bd-e6d9-48b7-962c-d820d923eeef</code></pre><h4 id="SEI-payload-content"><a href="#SEI-payload-content" class="headerlink" title="SEI payload content"></a>SEI payload content</h4><p>由于payload size是47个字节，除去16字节的uuid，剩下31个字节的content。由于content是字符串，所以有结束符”0x00”，有效的30个字符内容是：</p><pre><code class="hljs">Zencoder Video Encoding System</code></pre><h4 id="rbsp-trailing-bits"><a href="#rbsp-trailing-bits" class="headerlink" title="rbsp trailing bits"></a>rbsp trailing bits</h4><p>47个payload字节后的”0x80”（灰底色）即是rbsp trailing bits，在user_data_unregistered()里面都是按字节写入的，所以此时的NAL unit结尾写入的字节一定是0x80。</p><h3 id="SEI的生成"><a href="#SEI的生成" class="headerlink" title="SEI的生成"></a>SEI的生成</h3><p>生成SEI的方式很多，大致可以有：</p><p>1）对已有码流做filter，插入SEI NAL；</p><p>2）视频编码时生成SEI；</p><p>3）容器层写入时插入SEI；</p><p>以x264为例：</p><p>libx264支持多种SEI类型数据写入，常用的仍然是SEI_USER_DATA_UNREGISTERED，具体的写入函数x264_sei_version_write()位于libx264&#x2F;encoder&#x2F;set.c中。</p><pre><code class="hljs">int x264_sei_version_write( x264_t *h, bs_t *s )&#123;    static const uint8_t uuid[16] =    &#123;        0xdc, 0x45, 0xe9, 0xbd, 0xe6, 0xd9, 0x48, 0xb7,        0x96, 0x2c, 0xd8, 0x20, 0xd9, 0x23, 0xee, 0xef    &#125;;    char *opts = x264_param2string( &amp;h-&gt;param, 0 );    char *payload;    int length;     if( !opts )    return -1;    CHECKED_MALLOC( payload, 200 + strlen( opts ) );         memcpy( payload, uuid, 16 );    sprintf( payload+16, &quot;x264 - core %d%s - H.264/MPEG-4 AVC codec - &quot;     &quot;Copy%s 2003-2018 - http://www.videolan.org/x264.html - options: %s&quot;,     X264_BUILD, X264_VERSION, HAVE_GPL?&quot;left&quot;:&quot;right&quot;, opts );    length = strlen(payload)+1;         x264_sei_write( s, (uint8_t *)payload, length, SEI_USER_DATA_UNREGISTERED );         x264_free( opts );    x264_free( payload );    return 0;fail:    x264_free( opts );    return -1;&#125;</code></pre><p>libx264提供的uuid和上文举例的uuid一致，payload中主要记录了相关参数和版权信息。以上函数完成了SEI参数的构造，下面的函数x264_sei_write完成了具体语法的写入：</p><pre><code class="hljs">void x264_sei_write( bs_t *s, uint8_t *payload, int payload_size, int payload_type )&#123;    int i;         bs_realign( s );         for( i = 0; i &lt;= payload_type-255; i += 255 )    bs_write( s, 8, 255 );    bs_write( s, 8, payload_type-i );         for( i = 0; i &lt;= payload_size-255; i += 255 )    bs_write( s, 8, 255 );    bs_write( s, 8, payload_size-i );         for( i = 0; i &lt; payload_size; i++ )    bs_write( s, 8, payload[i] );         bs_rbsp_trailing( s );    bs_flush( s );&#125;</code></pre><p>以上写入的代码逻辑和标准语法说明保持一致。</p><h3 id="参考H264的官方文档"><a href="#参考H264的官方文档" class="headerlink" title="参考H264的官方文档"></a>参考H264的官方文档</h3><p>SEI在文档中是属于D.1</p><p>当payloadType &#x3D;&#x3D; 5时，是user_data_unregistered()</p><pre><code class="hljs">else if( payloadType = = 5 )      user_data_unregistered( payloadSize )</code></pre><p>user_data_unregistered()的实现</p><p><img src="/img/5.png"></p><ul><li>未登记的用户数据的SEI消息语义</li></ul><p>本消息包含未登记的用户数据，由 UUID 标识，其内容不由本建议书规定。</p><p>uuid_iso_iec_11578 应有一个由 UUID 指定的值，依照 ISO&#x2F;IEC 11578:1996 附件 A 的规程。</p><p>user_data_payload_byte 应为一个字节的数据，其语法和语义由 UUID 生成器指明。这块可以理解为用户所填入的META DATA的信息，每次写一字节</p><ul><li>整个SEI的语法</li></ul><p>参考7.3.2.3.1节</p><p><img src="/img/6.png"></p><p>参考：官方H264文档</p><p>参考：<a href="https://blog.csdn.net/weixin_42289213/article/details/125279309">https://blog.csdn.net/weixin_42289213/article/details/125279309</a></p><p>参考：<a href="https://blog.csdn.net/m0_60259116/article/details/127250846">https://blog.csdn.net/m0_60259116/article/details/127250846</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
